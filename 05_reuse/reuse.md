# Принципы повторного использования модуля в Python

## Параметризация другими типами
Поскольку Python изначально создавался как язык с динамической неявной типизацией,
там долгое время не было типов-генериков в стиле C++, например.
Однако, параметризация типами здесь допускается.

Во-первых, тип можно передавать как параметр в функцию и возвращать из функции,
что позволяет создавать типы динамически:
```Python
class Node(ABC):
    ...

class List(ABC):
    ...

def MakeListType(NodeType: Type[Node]) -> Type[List]:

    class MyList(List):
        __head: NodeType
        ...

    return MyList
```
Использование **функции** `type` для конструирования классов
открывает ещё больше возможностей.

Второй способ - использование генериков из стандартной библиотеки:
```Python
T = TypeVar("T", bound=Node)

class List2(Generic[T]):
    __head: T
    ...
```

## Объединение нескольких функций
Несколько функций можно объединить в рамках одного файла-модуля или сделать
методами одного класса-модуля.

## Семейство модулей
Классы-модули можно "упаковывать" внутрь других классов или файлов.

Файлы-модули можно объединять в библиотеки (каталоги файловой системы)
и собирать в пакеты (библиотеки - подготовленные для установки).

## Динамический выбор реализации
Поскольку язык Python изначально ориентирован на динамическую типизацию,
тип параметра можно спокойно рассматривать как ещё один параметр
**во время выполнения**:
```Python
def foo(a: int | float | str) -> str:
    match a:
        case int():
            return str(a + 1)
        case float():
            return str(a + 0.1)
        case str():
            return a + "1"
```

## Интеграция общего поведения нескольких модулей
Функции и классы, импортированные из других модулей-файлов можно реэкспортировать:
```Python
# a.py
import math
sin = math.sin

# b.py
from a import sin
...
```
