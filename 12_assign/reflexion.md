# Попытка присваивания

В Python нет передачи по ссылке как в C++, или указателей, как в C.
Поэтому я использовал список в качестве параметра `target`.

Жаль, что не додумался до изящного решения как в примерах:
```Python
target = Any.assignment_attempt(target, source)
```
Значение не изменяется, а *заменяется* - это почти stateless модель.

В примере на Python проверка типов выглядит слишком жёсткой.
Можно присваивать значение типа потомка переменной типа предка.
То есть, вместо
```Python
if isinstance(target, cls) and isinstance(source, cls):
    ...
```
сделать
```Python
if issubclass(source.get_type(), target.get_type()):
    ...
```

Копировать значение в функции тоже не обязательно, достаточно вернуть source
как в примере на Java.

Существенное отличие моего решения - в случае ошибки возвращается не Void
(он в этом решении не определён), а объект,
для которого не вызван его родной конструктор,
а вызван только конструктор `General`
(в Python так можно сделать с помощью `__new__`).
Для этого объекта затем устанавливается статус присванивания `TYPE_MISMATCH`.
