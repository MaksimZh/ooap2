# ------------------------------------------------------------------------------
# Вариант 1: метод публичен в родительском классе А и публичен в его потомке B

class A1:
    def a(self) -> None:
        print("a")

class B1(A1):
    pass

A1().a()
B1().a()
print()

# Вывод:
# a
# a


# ------------------------------------------------------------------------------
# Вариант 2: метод публичен в родительском классе А и скрыт в его потомке B

class A2:
    def a(self) -> None:
        print("a")

class B2(A2):
    def b(self) -> None:
        # метод родительского класса доступен потомку
        print("b{")
        super().a()
        print("}b")

# Ставим "заглушку" в классе-потомке
setattr(B2, "a", None)

A2().a()
B2().b()
try:
    B2().a()
except TypeError as e:
    print(e)
print()

# Вывод:
# a
# b{
# a
# }b
# 'NoneType' object is not callable


# ------------------------------------------------------------------------------
# Вариант 3: метод скрыт в родительском классе А и публичен в его потомке B

class A3:
    def _a(self) -> None:
        print("a")

class B3(A3):
    def a(self) -> None:
        # метод родительского класса доступен потомку
        super()._a()

# Метод вызвать можно, но линтер выдаст предупреждение
A3()._a()
B3().a()
print()

# Вывод:
# a
# a


# ------------------------------------------------------------------------------
# Вариант 4: метод скрыт в родительском классе А и скрыт в его потомке B

class A4:
    def _a(self) -> None:
        print("a")

class B4(A4):
    pass

# Метод вызвать можно, но линтер выдаст предупреждение
A4()._a()
# Метод вызвать можно, но линтер выдаст предупреждение
B4()._a()
print()

# Вывод:
# a
# a
