# Основополагающий принцип открытости-закрытости модуля
После прочтения решения понял, что у меня есть предубеждение против "открытых"
классов, если они не абстрактные.
Как будто мы оставляем место под какие-то не очень гибкие костыли и
провоцируем пользователей переопределять методы родительских классов
(что черевато, например, нарушением принципа подстановки Лисков).

В моём примере для расширения языка описания схемы расчёта лучше придумать
какую-то систему плагинов.
Тогда их будет легче сочетать друг с другом, чем при наследовании.
Аналогично можно поступить в примере с анализатором логов.

В случае с графическим интерфейсом напрашивается выделение отображения
элементов в отдельную абстракцию, типа моделей персонажей в компьютерных играх.

Пример с однонаправленным и двунаправленным списком из предыдущего курса -
для меня самый неприятный.
Здесь наследование возможно только потому, что мы используем
узлы с двойной связью.
Если бы мы действительно сначала сделали однонаправленный список, а потом
его расширяли, то пришлось бы менять класс узлов, а это грубое нарушение
закрытости уже готовых модулей.

Надеюсь, в дальнейшем, с новыми знаниями, ко мне придёт понимание где
и как использовать наследование так, чтобы оно не вызывало дискомфорт.
